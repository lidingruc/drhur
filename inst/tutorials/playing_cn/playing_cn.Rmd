---
title: "Learning R with Dr. Hu and His Friends"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
    css: "style_ui.css"
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(tidyverse)
library(gapminder) 
library(lubridate)
```

# 数据输入／输出

## 导语

大家好！我们是drhur开发团队，欢迎来到“Learning R with Dr. Hu and His Friends”!

现在你进入的是通往Rexpert之路的第一站，胡老师和他的朋友们将引领你走入R的世界，领略其中风采。

R是你与计算机之间的可靠翻译。这位翻译十分忠诚，它会不打折扣地让计算机执行你的指令。这位翻译也很古板，你哪怕说错、说漏一个字，它会不知所措，直到你把指令修改到它听懂为止。

学习R语言，就是在学如何用R听得懂的话同它交流，让它把你脑海里的计划变成现实。你熟练在地掌握这门"外语"后，你会更加认识到R的强大能力，也会惊叹于同你朝夕相处的计算机还能如此帮助你的工作！

希望这节课能让你初步了解R语言的**说话风格**！对，就是“说话风格”——R作为一种编程语言，本质上就是一种与计算机对话的方式。
我们常见的C++, Java和Python也是如此。
了解一种语言的“说话方式”的特点有助于我们更好的通过它与计算机进行“**沟通**”。

## 知识点

### R and Rstudio
- R

R是实现上述"翻译"功能的软件，你能通过[官方网站](https://www.r-project.org) 免费获得它，我们与计算机的沟通便是通过R进行传达的。

- Rstudio

R-studio是本次学习中需要使用的配套软件，你能通过[官方网站](https://www.rstudio.com) 获得它。众所周知，R是一位古板的翻译，它需要像**R-studio**这样的助手让你和R的沟通更加顺畅，也能帮助管理你和R正在进行的工作。在实际操作中，R-studio像是一个浏览器，我们与R的沟通在其搭建的平台上进行，我们录入指令和收到反馈也往往通过类似R-studio的软件进行。

### 对象是什么？

初学R语言必然有一些不适应，仿佛在用蹩脚的英语同机器聊天。但当你运用R语言写出并运行了第一条代码时，你就已经完成了学习R语言中最重要的一步，那就是开始使用它。

首先，我们先一起了解一下R的操作对象。

R是对象指向型编程（Object-oriented programming）语言。
这类语言的基本操作单位是类（class）和对象（object）。
其中，类是概括性的，规定了其所属对象的属性类型，是其所辖对象的模板，比如在`国家`这一类下，所有个体都包含人口、疆域、政权类型等属性。
对象是类模板的一个具象，比如基于`国家`类可以创建的对象`中国`、`法国`、`爱尔兰`等。

什么是对象（object）？
R是对象指向型编程（Object-oriented programming）语言。
这类语言的基本操作单位是类（class）和对象（object）。
其中，类是概括性的，规定了其所属对象的属性类型，是其所辖对象的模板，比如在`国家`这一类下，所有个体都包含人口、疆域、政权类型等属性。
对象是类模板的一个具象，比如基于`国家`类可以创建的对象`中国`、`法国`、`爱尔兰`等。

R一般要面对数量庞大、各有不同的对象（object），往往要将具有相同或相似属性的对象集合成类（class），再分别依据需要予以处理，这是R能够为你高效工作的**处世哲学**。

为了更好地理解R的思考方式，不妨来看一看下面这个小故事。例如，如果有一个收拾房间的任务，你可能会用如下流程完成：

1. 将脏上衣放进洗衣机；
1. 将脏外裤放进洗衣机；
1. 将编程书放进书柜；
1. 将数学书放进书柜；
1. 将笔放进笔筒；
1. 将橡皮擦放进笔筒。

这是一种类似于面向过程编程（Procedure-oriented Programming）的解决方案，如果交给一个程序做类似的事情，它可能这一次能顺利完成了收拾房间的任务。但如果下一次收拾房间时没有需要放入书柜的编程书，它就会卡在环节c不知所措，需要你重新为这次收拾房间编写程序。

因此，对于R更喜欢的方式是：

- 将脏上衣、脏外裤归类为脏衣物；将编程书、数学书归类为书；将笔、橡皮擦归类为文具。
- 将脏衣物放进洗衣机；将书放进书柜；将文具放入笔筒。

这种类似于面向对象编程的解决方案将会给予你很大的便利，你只需告诉R房间里的物品分别属于脏衣物、书和文具，每当你要R执行收拾房间的指令时，它就会自主地按照各个物品的分类完成任务，而不需要你每一次都为R精心定制独一无二的工作计划。相信这种轻松、灵活的对话方式能让你更好地与R沟通。
其中，放进洗衣机、放进书柜、放进笔筒的动作也需要通过R语言表达，我们往往通过函数（function）来实现这些动作。


### 函数是什么？

函数在R语言起到的作用便是告诉R面对不同类型的对象，应该用何种方法去处理，使得输入的对象成为你想要的输出结果。

例如在上个例子中，属于脏衣物的脏外裤是输入对象，将其放入洗衣机是处理脏衣物的函数，已经放进洗衣机的脏外裤便是输出的结果。

如下图所示，如果将手的形状作为输入对象，将影子比喻为输出对象。如此，将手的形状处理成影子形状的那束光便行使了函数的功能。R可处理的对象十分丰富，一组数据、一串文字、一张图片......都能成为对象。赋值对象的过程，仿佛在给对象们取名字。


```{r out.width = "80%", echo = FALSE}
knitr::include_graphics("images/handShadow.gif")
```

```{r funIllustration, eval = FALSE}
light <- function(finger){
  {{shadow <- finger + 5}}
}
handShadow <- light(finger = 3)
handShadow
```

### 数据包是什么

数据包（package）相当于你智能手机里的app。当你买到手机的时候，功能都是有限的，通过app，我们可以让手机的功能极大丰富起来。

R拥有大量的开发者和共享者（未来的你也能成为其中一员），他们十分愿意将自己编写的工作计划分享出来，以数据包（package）的形式供其他研究者、学习者使用，例如本次学习所使用的drhur数据包。

希望上述介绍能够让你更好地理解接下来的讲解。接下来，就让我们开启这一段完全零基础学习R语言、重新认识你的计算机的奇妙旅程吧！

###

本章节我们将要学习的知识点有以下几个方面：

1.  输入/输出数据
2.  保存数据
3.  合并数据

## 数据输入

### 对象赋值 `<-`

语法：<名称> `<-` <对象>

举例：

```{r object, echo=TRUE, eval=TRUE}
aValidObject <- 1:5
aValidObject
```

这是一个激动人心的时刻，因为你学会了用R语言写出了第一条代码！

注意，当一行代码以"#"开头，则意味着这一行将成为夹在代码中的注释，并不会在代码运行中被R使用，这是一个给自己或合作者添加注意事项的实用技巧。

+ 对象名称有如下规则：
    1. 不要以数字开头 (错误: `1stday`)
    1. 除了 `.` 和 `-`以外没有其他特殊符号(错误: `M&M`)
    1. 区分大小写 (`X != x`) `!表示“非”/“否”，`!=`表示“不等于”
    1. 如需必要请勿重写内置函数 (避免: `list <- c(1:5)`)

如果不按照R能听懂的方式命名对象，R会用bug向你表示抗议！

### 另一种赋值符 `=`

用法和`<-`等效。
但更多写过更倾向使用 `<-` 而不是 `=`。

为什么会这样咧？

```{r out.width = "80%", echo = FALSE}
knitr::include_graphics("images/APLkeyBoard.png")
```

上图是最开始R设计者所使用的键盘样式。
仔细观察便会发现，这个键盘并不能直接输入`=`，与我们习惯使用的键盘相比，这类键盘能够直接输入`->`和`<-`,因而成为了R习惯使用的赋值表达方式。在实际操作中，使用`->`来赋值比`=`具有更多优点。

+ 指向直观

```{r arrow}
a <- 12
25 -> b
```


+ 不可以和“等于”混淆（本章最后一节会详述）
+ 可以通过快捷键一次性输入
    + PC: `Alt + -`
    + Mac: `option + -`


### 什么时候用 "="?

如果你不想创造一个对象，不妨考虑使用`=`来表达。当处理大量数据时，使用`=`处理数据将会减轻计算机的负担，因为它不必专门腾出存储空间将这些数据作为对象保留下来。

在下方[练习1.1]中，我们将数字区间1〜10赋值于y，并求y的中位数（使用了函数median）。你在运行代码时，R始终保留着y所拥有的赋值。因此，如果单独输入"y"，R将向你展示y的赋值。

然而，如果你用`=`将数字区间1〜10赋值于x，R仅仅将这行代码当作一道数学题来做，但不会记忆答案。当你单独输入x，R将会提示你对象x不存在。不妨在练习中试一试！

在这个地方，你将遇到R送出的第一个bug。R虽然古板得不近人情，它习惯于用毫不客气地红字告诉你"我听不懂你在说什么"，但也会细心地标注出"你在哪里错了"。认真阅读每一个bug，善于运用网络去搜索解决方案，你将会越来越懂得如何与R和睦相处。

```{r echo=TRUE,eval=TRUE}
median(y <- 1:10); y
median(x = 1:10); 
```


### 挑战时间！

请创建一个合规和不合规的对象：

```{r objectEg, exercise = TRUE}
# 一个合规对象

# 试着创建一个不合规的对象

```


## 数据读取

### 内置数据

为了给使用者更方便地测试代码和加强练习，R有一套内置数据可供使用，这也给我们提供了便利。我们可以用data()函数对其进行读取。通过网络搜索，你能找到更多的R内置数据，作为一种**toydata**用来练手！示例中出现`::`表示了从属关系，即从gapminder中读取与其同名的数据。

```{r mtcars, exercise}
data(mtcars)
```

### 可直接读取数据

R有4种可以直接读取的数据。分别是：

- `.RDS` :这是R自带的数据格式，只能存储单个对象的数据
- `.RData`:也是R自带的数据格式，能够存书多个对象的数据
- `.txt` :常见文本格式
- `.csv`:常见数据格式

那么我们如何读取这些数据呢？可以用以下语法实现：

语法： <名称>`<-` <读取函数>(<数据路径>)

```{r input, eval = FALSE}
df_rds <- readRDS("aDataset.rds")
df_txt <- read.table("D:/aDataset.txt")
df_csv <- read.csv("./aDataset.csv")
```

`readRDS`、`read.table`、`read.csv`分别是`RDS`、`txt`、`csv`三种文件格式的读取函数。请注意：

- 如果数据文件存储于R读取的路径（往往是R的根目录）之中，可以在数据路径位置直接填写文件名。
- 在读取路径中，`\`是不能够被R直接读取的，需要将其修改为`/`,此问题常见于Windows系统。
- 建议使用英文命名文件与文件夹。R的中文水平不大好，如果路径中夹带中文，可能会导致读取失败，其他场景亦如此。总而言之，尽量不让R处理带中文的代码。
- 如在路径中遇到`.\`的情况，这是相对路径的表达方式，建议结合具体情况通过咨询、搜索来获得解决方案。

### 调用包读取数据

实际操作中，需要处理的数据文件格式不止于以上举例的4种。因此不少贡献者开发了众多数据包用于数据读取，并附带不少便捷的功能。以下是我们向大家推荐的数据包，并展示了使用语法。你可以按需求去探索如何使用它们！


```{r eval=FALSE}
# SPSS, Stata, SAS
library(haven)
df_spss <- read_spss("WVS7.sav")
df_stata <- read_dta("WVS7.dta")
df_sas <- read_sas("WVS7.sas7bdat")  

# 表格的快速导入
library（reader）
df_csv <- read.csv("WVS7.csv")
df_table <- read.table("WVS7.csv/txt")

# Excel表格
library(readxl)
df_excel <- read_excel("WVS7.xls")
df_excel2 <- read_excel("WVS7.xlsx")

# JSON (JavaScript Object Notation)
library(rjson)
df_json <- fromJSON(file = "WVS7.json" )
```


## 数据分类

1. 向量 (vector)
2. 矩阵 (matrix)
3. 数据框 (data frame)
4. 列表 (list)
5. 阵列 (array)


### 向量

向量（vector）是R语言中最基本的数据类型，执行组合功能的函数`c()`可用来创建向量

+ 数字向量（numeric vector）

```{r echo=TRUE,eval=TRUE}
vec_num1 <- c(1, 2, 3) #整数
vec_num2 <- c(1:5) #表示1-5 
vec_num3 <- c(1.5, -2.34, NA)

vec_num1; vec_num2; vec_num3

# c(1.5:3) 的结果是什么?
```

以上分别展示了向量的枚举、连续、离散等3种赋值方式。值得注意的是第三种形式中出现的`NA`表示的是`not available`，意味着该值缺失，是对该处数据存在状态的一种表达方式。单独输入三个向量的名称，看看R是如何向你反馈3个向量的数值，记得尝试一下#后的小测试哦！

###

+ 字符向量（character vector）

```{r eval=TRUE,echo=TRUE}
vec_chr <- c("R is hard.", "But I can nail it.")
vec_chr
```

输入的字符向量需要放在""里，R就会明白这些字符不是指令的一部分，也就不会执着地要弄懂""内的字符，而是按照你的意愿去搬运它们。注意，单个向量只能使用一种数据类型哦！

###

+ 逻辑向量（logic vector）

```{r echo=TRUE,eval=TRUE}
vec_tf <- c(TRUE, TRUE, FALSE)
vec_tf
# c(TRUE, TRUE, FALSE) == c(1, 1, 0)
```

逻辑向量是用来表示判断的向量，只能填入`TRUE`、`FALSE`代表正确或错误。例子中出现的`==`是等于的意思，还记得不等于如何表达吗？

###

+ 类别向量（factor vector）

```{r echo=TRUE,eval=TRUE}
vec_fac <- factor(c(1, 2, 2, 3), labels = c("Apple", "Pear", "Orange"))
vec_fac
levels(vec_fac)
```

类别变量分为**水平**`levels`和**标签**`labels`两个变量，用于对一些离散变量的数据处理。

例如，如下类别变量实现了将数字1、2、3作为三个水平，分别代表apple、pear、orange。

当你运行这段代码，`c(1,2,2,3)`便能够被R表示为其所代表的3种水果。通过`level()`函数，你便能查询不同数字水平所代表的标签。其中，水平的不同数字之间不具有数学意义上的可比性，即它们之间不能够比大小，仅仅是针对标签的一个编号罢了。
水平和标签是从左到右一一对应的关系。如果我们将水平里的编码倒过来写，其代表的标签也会随之改变，运行下一串代码试试看！


```{r echo=TRUE,eval=TRUE}
vec_fac2 <- factor(c(1, 2, 2, 3), levels = c(3, 2, 1), labels = c("Apple", "Pear", "Orange"))
vec_fac2
```


###

+ 时间向量（POSIXct/POSXlt vector）

`as.POSIXct` (numeric input), `as.POSIXlt` (character input)
其中POSIXct是整数存储、POSIXlt是列表存储
```{r time, exercise}
Sys.time() # 获取当前时间
today()   # 获取当日的 年月日
now()  # 获取当日的 年月日 时分秒  时区
# CST为操作时电脑ip所在的时区

# The full pack
time1 <- Sys.time()
time2 <- as.POSIXlt(Sys.time())
time2$wday # week of the day

## 如果我只在乎日期呢？
```

```{r time-solution}
Sys.Date()
date1 <- as.Date("2019-01-02")
class(date1)  # 查看数据类型
```

### 矩阵

矩阵（matrix）是具有维度属性的向量，矩阵都是二维的，和向量类似，矩阵中也仅能包含一种数据类型

```{r out.width = "80%", echo = FALSE}
knitr::include_graphics("images/matrix.gif")
```

###

创建矩阵主要有三种方法：

+ 手动创建: `matrix`

当你输入数字总数为20、一共要4列，聪明的R便会自动生成为5列。
当你输入<矩阵名称>[行数,列数]，便能够查询相应位置的值。

```{r matrixR}
A <- matrix(1:20, ncol = 4) #创建一个数字1-20，5行4列的矩阵（col为列，row为行）
A
A[2, 3]
```

###

+ 矢量+维度: `dim()`

首先对M赋值一个数字向量，随后通过`dim()`规定行列，一个矩阵就生成啦！其中，`c(4,5)`代表4行5列。

```{r}
M <- c(1:20)
dim(M) <- c(4,5) #4行5列       
M
```

###

+ 绑定行/列: `cbind()`和`rbind()`
```{r}
x <- 1:4
y <- 5:8
cbind (x, y)
rbind (x, y)
```

### 阵列

阵列，顾名思义就是列的“阵”，可用于记录更高维度的数据，可通过`array`函数创建。

```{r array}
# 创建两个长度不同的向量。
vector1 <- c(5,9,3)
vector2 <- c(10,11,12,13,14,15)

# 把这些向量输入到数组中。
result <- array(c(vector1,vector2),dim = c(3,3,2))
result
```

### 列表

列表（list）是一种可包含多种不同类型对象的向量，是一些对象（或成分，component）的有序集合，列表中既可以有向量也可以有矩阵等。是一种十分常用的数据类型。列表的这一功能如同一个文件夹，能把某一组相关联的对象组合起来，使你能够像翻阅台账一般查看和处理这些对象。

以下展示了唐僧师徒的名字，权力以及是否成佛的列表。

```{r list}
ls_monks <- list(name = c("Wukong Sun", "Sanzang Tang", "Wuneng Zhu", "Wujing Sha"),
                 power = c(100, 20, 90, 40),
                 buddha = c(TRUE, TRUE, FALSE, FALSE))

ls_monks
```

### 数据框

数据框（Data Frame）是一种特殊的列表/矩阵，其中所用元素长度都相等，列表中的每个元素都可以看作一列，每个元素的长度可以看作行数。通过数据框，能使得数据以我们更熟悉、更亲切地方式展示出来，让你的阅读体验更加友好。

在R中，使用`data.frame()`创建数据框

```{r dataframe}
df_toy <- data.frame(female = c(0,1,1,0),
           age = c(29, 39, 38, 12),
           name = c("Iron Man", "Black Widow", "Captain Marvel", "Captain America"))

df_toy
```


## 合并数据

### 教学数据

我们采用密歇根大学政治学教授Inglehart在[World Values Survey](https://www.worldvaluessurvey.org/wvs.jsp)中使用的数据作为案例来进行下面的讲述。
让我们首先来看看数据

### 行合并

此时，就可以使用行合并函数`bind_rows()`，通过<合并后对象名称><-bind_rows(<对象1>,<对象2>)这样的语法来实现。来操作一下试试吧！

```{r out.width = "95%", echo = FALSE}
knitr::include_graphics("images/rowBind.png")
```

假设我们有中国和日本人际信任的数据，如何把它们合并在一起呢？

```{r ex_append, exercise = TRUE}
WVS7_China <- WVS7[WVS7$country == "156", 9:11]
WVS7_Japan <- WVS7[WVS7$country == "392", 9:11]
```

```{r ex_append-solution}
library(dplyr)

WVS7_asia <- bind_rows(WVS7_China, WVS7_Japan) 
#按行连接，不需要列名相同
```

### 列合并

但如果我们有很多来自中国的向量数据，如何将它们整合起来呢？这时就可以使用列合并函数`bind_cols()`来实现，语法同上类似。来操作一下试试吧！


```{r out.width = "95%", echo = FALSE}
knitr::include_graphics("images/columnBind.png")
```

```{r ex_columnBind, exercise = TRUE}
WVS7_country <- WVS7$country
WVS7_year <- WVS7$year
```

```{r ex_columnBind-solution}
bind_cols(WVS7_country, WVS7_year) #按列结合时需要行名相同
```

### 索引合并

`dplyr::*_joint`函数

```{r out.width = "95%", echo = FALSE}
knitr::include_graphics("images/join.png")
```

1. 左连接（left_jion): 保留x中的所有观测,如果x中的key变量,在y中有多个同样的key,那么所有的结合可能都会罗列出来，索引合并力求一一对应地让不同来源数据进行匹配合并。

总而言之，左合并保留了前一组数据的框架，并完全保留前一组数据中的内容，后一个数据则是根据这一框架"裁剪"自己，融入其中。


```{r left_jion, eval=FALSE}
left_join(x, y, by = "key")
```

2. 右连接(right_jion): 保留 y 中的所有观测

```{r right_jion, eval=FALSE}
right_join(x, y, by = "key")
```

### 挑战时间

如果我们有两组数据分别来自不同的源头，又有不同的行数，该如何把它们准确的合并在一起呢？

```{r ex_join, exercise = TRUE}
WVS7_country <- dplyr::select(WVS7,country, year)
WVS7_year <- dplyr::select(WVS7,year,id)
```

```{r ex_join-solution}
WVS7_countryYear<- left_join(WVS7_country, WVS7_year)
```


## 数据输出

我们距离完成一个数据处理的任务越来越近了！这一部分将教会你如何把自己的工作成果输出。

语法：<函数>(<代存数据>，file = <存储路径>)

以下两条分别展示了储存为RDS、RData的语法示例：

### 储存为R数据

```{r saving, eval = FALSE}
saveRDS(WVS7_country, file = "WVS7_country.rds")
save(WVS7_country, WVS7_year, file = "WVS7_countryYear.rdata")
```


### 储存为csv文件

```{r savingCSV, eval = FALSE}
write.csv(WVS7_country, file = "WVS7_country.csv")
```

提示: 如果你的数据是中文的，可能会出现存储csv乱码现象。
这个我们之后遇到时候再讲解。

当然了，你可以把数据以STATA, SPSS, Excel格式存储下来, 不过你真的想这样吗？如果这些数据还需要再次进入R使用，那储存为上述格式实际上是"多拐了几道弯"--因为它们需要被再次转译为R能够接受的格式。

储存格式不同，储存体积也不同。在绝大多数情况下，储存为R格式是最节约时间、空间的做法。下列关于不同存储方式的性能比较一定会让你一目了然。

### 体面地储存数据

STATA (.dta, \<14): 3.16 G = R (.rds): 0.05 G

| **Method**       | **Average Time** | **Minimum** | **Maximum** |
|:-----------------|:----------------:|:-----------:|:-----------:|
| base::readRDS    |       19.65      |    18.64    |    21.01    |
| fst::read\_fst   |       1.39       |     0.56    |     3.41    |
| haven::read\_sav |      104.78      |    101.00   |    111.85   |
| qs::qread        |       3.33       |     3.00    |     4.24    |

: 四种在R中读取GSS数据的方式所用的平均时间（以秒计）


| **Method**      | **Average Time** | **Minimum** | **Maximum** | **File Size** |
|:----------------|:----------------:|:-----------:|:-----------:|:-------------:|
| base::saveRDS   |       98.36      |    93.09    |    103.24   |    30.9 MB    |
| fst::write\_fst |       2.70       |     1.86    |     4.05    |    122.1 MB   |
| qs::qsave       |       5.03       |     4.35    |     6.62    |    44.6 MB    |

: 在R中写入GSS数据（及文件大小）所用的平均时间



## 数学计算

咱们来做几道数学题来轻松一下吧！
R遵循着与我们所学的代数预算法则，在这个小练习中，我们依次展示了从不等式的传递性、四则运算等简单计算到矩阵、逻辑计算等高等数学的计算。学会使用这些计算语法，可以帮你解决一些学习研究中遇到的计算问题。

```{r math, exercise = TRUE}
x <- y <- 42

# 基础数学
x + (1 - 2) * 3 / 4

# 高等数学
x^2;sqrt(x);log(x);exp(x)

# 矩阵运算
z <- matrix(1:4, ncol = 2)
z + z - z
z %*% z  # inner multiplication
z %o% z  # outter multiplication

# 布尔逻辑计算
x == y; x != y
x & y; x | y
x > y; x <= y
```

在[这里](https://towardsdatascience.com/intro-to-r-linear-algebra-2a4de2506c93)查看更多线性代数在 R 中的应用。

## 本节知识点总结

1. 输入
    + `readTYPE`
    + `read_type`
    + `read.type`
1. 保存
    + 向量
    + 矩阵/data.frame
    + 列表, 数组
1. 输出
    + `save`
    + `saveTYPE`