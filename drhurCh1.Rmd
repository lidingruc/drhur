---
title: "Learning R with Dr. Hu and His Friends"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
    css: "style_ui.css"
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(tidyverse)
library(gapminder) 
```


# 导语

大家好，欢迎来到“Learning R with Dr. Hu and His Friends”!
这是一门专门为系统学习R语言设计的课程。
在课程中，我们将带领大家和R交流、对话，进而交上朋友，让它成为你科研、工作上的强大助力。
与其他既有课程和教材相比，这本教材有三个突出特点：

第一，文科生看得懂。
这门课程缘起于我建立“让文科生也学得会编程课程”的夙愿。
我本身就是纯文科出身，在接触R之前对编程几乎没有了解。
但后来因为科研原因，陆续学习、使用R语言，并在之后又学习了Python、C++等，也推出了数个R语言软件包(我们会在之后的课程中陆续介绍到它们)，至今获得了全球二十余万的下载量。
学习的过程中，我走了不少弯路，但也有比理工科同事理解的更快、更好的时候。
这本教材将我这些年学习、教学R语言的经验进行了系统梳理总结。
内容上并不会比那些理工科教材浅薄或零碎，而无论是课程安排还是教学角度上却都有很好的“文科向”，方便理解和记忆。

第二，一个人和一群人的教学。
在多年的编程和方法论教学过程中，我发现学习的难处往往不在于所授知识有多深、操作有多复杂，而在于“会的教不会的”这个状态。
正所谓“会者不难”，“会者”也往往不再记得“不会”的难处，以及是怎么从不会到会的。
因此我们这个教材，引入了集体教学模式。
现在正在学习的，不仅仅有屏幕前的你，还有飞宝、萌萌、哲哥等几位小朋友。
他们会伴随你走过整个学习过程，也会把他们对于某些他们觉得“之前不明白，但之后明白了”的知识点，用学生的话表述出来，希望能给当下正在学习的你们带来帮助。

第三，活的教科书。
这本教材课程设置将分为两个阶段，我称之为“R Survivors”和“R Expert"。
前一个阶段筑基，后一个阶段进阶。
两个阶段的着眼点不同，复杂程度也不同，但有一点相同：那就是贯穿每一节课程，你都可以在各个知识点原地进行练习。
教材通过`R Shiny`将教材与R系统关联起来，实现学与用的无缝联系，免去照着书本一个个字敲的古早学习方式，最大程度减少无必要精力耗费，增强学习效率。
同时，在这种互动操作方式下，你的所有错误操作都会得到和在R里一样的错误或者警告反馈，让你能够实时检查，错在哪，为啥错。
正如美籍匈牙利数学家乔治·波利亚所说，真正学会一件事“除了要正确理解它，还必须知道如何误解它。”

以上就是对本教材的一点小简介，希望能激起你对学习R的热情，树立学习的信心。
下面，我们的学习正式开始。


# 与R握个手

现在你进入了是通往`R expert`之路的第一站，对R有个概括性的了解。
我称之为“和R握个手”，要和谁交朋友，总要先有个认识不是？
这里包含三个步骤：“看面相”（R语言概貌），“请进门”（R程序安装）和“喝点水”（R语言包安装）。

## 看面相

（见课件）

## 请进门

相过面后，如果你决定要和R做朋友，那就要把她请到你的本地电脑或者服务器上。
方法和安装任何软件一样，你在任何浏览器上搜索“R language”，通常第一个蹦出来的就是R语言的主页[https://www.r-project.org/about.html](https://www.r-project.org/about.html)。
你在侧边栏“Download”下的“CRAN”链接里你就可以找到R语言的下载镜像。
你可以选择第一个“0-Cloud”或者在地区上离你最近的那个镜像，比如北京的朋友们可以选择[清华](https://mirrors.tuna.tsinghua.edu.cn/CRAN/)的或者[北外](https://mirrors.bfsu.edu.cn/CRAN/)的。

下载安装完成后，我还推荐大家一个R专属的Integrated Development Environment (IDE)。
它本质上就是个浏览器，让R语言程序和反馈都能更好的显示和排布。
现在世界上最流行的IDE当属Rstudio，我们这里也推荐大家使用这个。
安装方法也很简单，在任何浏览器里搜索“Rstudio”， 进而转到其官方网站[https://www.rstudio.com/], 在里面就可以免费下载到[Rstudio Desktop IDE](https://www.rstudio.com/download/)。
下载安装完成后，恭喜你，R已经成功进门，可以进行下一步的交流了。

> 萌萌：请注意！请注意！请注意！安装上述软件时候，强烈建议大家安装到没有中文、没有空格的安装路径，比如“C:\R”或“~/R”。Rstudio也是。这一点几乎对于所有编程语言都适用。如果你的安装路径里有中文或者空格，这些程序都有很大几率表现异常——尤其是在Windows系统里——其异常程度，嗯，令人发指！

## 喝点水

请客进门后，作为主人，我们通常要端上饮品，拿些点心。
一方面表现好客，另一方面也是客人理解主人的一种途径。
比如，主人端上的咖啡加西点，那主人可能比较喜好西洋风；但如果端上的是酽茶加瓜子，那主人则更可能是个中国风爱好者。
对于R语言来说，安装后，我们要进行一步程序包的安装工作，就相当是这一步：通过安装不同的程序包，R就能理解你最长从事的工作或最需要进行的分析有哪些，她好提前做好准备。
程序包不必也不可能一次性装全，可以随用随装，不断加深R对你的理解。

下面以安装我们互动教材`drhur`的程序包举例加以说明。
安装可以通过两种方式进行：一种是实在Rstudio里通过“Package-Install”来实现，另外一种是通过代码实现，代码如下：

```{r install-drhur, eval=FALSE}
install.packages("drhur", dependencies = TRUE)
```

这也是我们向大家引介的第一个R语言命令函数。
关于命令函数，我们之后会专门介绍，这里仅做简要说明：`install.package`是函数名，`"drhur"`是处理的数据，这里就是一个程序包的名字，`dependencies = TRUE`则是对处理过程提的一个条件，意思是对能让这个包顺利运行的基础包也请自动安装。

> 萌萌：请记得在输入任（！）何（！）R语言命令时候把输入法调回英文，请自行脑补我是怎么花了4个小时研究知道的……

以上命令是从CRAN安装R的过程，对大部分R程序包都适用。
但由于CRAN对于R程序包有一个相对较高的集成化标准和相对繁琐的审核过程，有的研究者不想在这个上面多花时间，就会把自己还在开发阶段的程序包或者适用版本放在开源共享平台上，比如Github, Gitlab等等。
要想安装这些包，则需要另一个命令。
比如要想安装`drhur`的开发者版本则需要以下命令:

```{r install-github, eval = FALSE}
remotes::install_github("sammo3182/drhur", dependencies = TRUE)
```


# 和R聊两句

Ok, 现在R已经被你请进门、安顿住。
我们这一章的目的是进一步她进行了解，知道她的身世、喜好，并据此跟她进行交流。
我们要完成以下三个任务：

1. 了解R语言的核心书写逻辑
1. 了解R语言的数据类型
1. 学会如何将数据读进R和存出来。

## 解R语言的核心书写逻辑

### 对象是什么？

R是对象指向型编程（Object-oriented programming）语言。
这类语言的基本操作单位是类（class）和对象（object）。
其中，类是概括性的，规定了其所属对象的属性类型，是其所辖对象的模板，比如在`国家`这一类下，所有个体都包含人口、疆域、政权类型等属性。
对象是类模板的一个具象，比如基于`国家`类可以创建的对象`中国`、`法国`、`爱尔兰`等。


### 函数是什么？

```{r out.width = "80%", echo = FALSE}
knitr::include_graphics("images/handShadow.gif")
```

```{r funIllustration, eval = FALSE}
light <- function(finger){
  {{shadow <- finger + 5}}
}
handShadow <- light(finger = 3)
handShadow
```

### 数据包是什么

数据包（package）相当于你智能手机里的app。
当你买到手机的时候，功能都是有限的。
通过app，你可以让手机的功能极大丰富起来。

###

本章节我们将要学习的知识点有以下几个方面：

1.  输入/输出数据
2.  保存数据
3.  合并数据

## 数据输入

### 对象赋值 `<-`

语法：<名称> `<-` <对象>

举例：

```{r object}
aValidObject <- 1:5
aValidObject # 展示对象内容
```

+ 命名规则
    1. 不要以数字开头 (错误: `1stday`)
    1. 除了 `.` 和 `-`以外没有其他特殊符号(错误: `M&M`)
    1. 区分大小写 (`X != x`) `!表示“非”/“否”，`!=`表示“不等于”
    1. 如需必要请勿重写内置函数 (避免: `list <- c(1:5)`)
### 另一种赋值符 `=`

用法和`<-`等效。
但更多写过更倾向使用 `<-` 而不是 `=`。

Why?

```{r out.width = "80%", echo = FALSE}
knitr::include_graphics("images/APLkeyBoard.png")
```

+ 指向直观

```{r arrow}
a <- 12
25 -> b
```

+ 不可以和“等于”混淆（本章最后一节会详述）
+ 可以通过快捷键一次性输入
    + PC: `Alt + -`
    + Mac: `option + -`


### 什么时候用 "="?
当你不想创建一个对象的时候,请看以下例子

```{r sideEffect, exercise = TRUE}
median(y <- 1:10); y
median(x = 1:10); x
```

### 挑战时间！

请创建一个合规和不合规的对象：

```{r objectEg, exercise = TRUE}
# 一个合规对象
# 试着创建一个不合规的对象
```


## 数据读取

### 内置数据

```{r mtcars, exercise}
data(mtcars)
#data(gapminder::gapminder)
```

### 可直接读取数据

可读取数据类型

- `.RDS` (单一对象)
- `.RData` (多个对象)
- `.txt` 
- `.csv`

语法： <名称>`<-` <读取函数>(<数据路径>)

```{r input, eval = FALSE}
df_rds <- readRDS("aDataset.rds")
df_txt <- read.table("D:/aDataset.txt")
df_csv <- read.csv("./aDataset.csv")
```


### 调用包读取数据

通过`library`或者`require`调用数据包，然后使用其中的命令。


```{r eval=FALSE}
# SPSS, Stata, SAS
library(haven)
df_spss <- read_spss("<FileName>.sav")
df_stata <- read_dta("<FileName>.dta")
df_sas <- read_sas("<FileName>.sas7bdat")  
# 表格的快速导入
library（reader）
df_csv <- read.csv("<FileName>.csv")
df_table <- read.table("<FileName>.csv/txt")
# Excel表格
library(readxl)
df_excel <- read_excel("<FileName>.xls")
df_excel2 <- read_excel("<FileName>.xlsx")
# JSON (JavaScript Object Notation)
library(rjson)
df_json <- fromJSON(file = "<FileName>.json" )
# XML/Html
library(xml)
df_xml <- xmlTreeParse("<url>")
df_html <- readHTMLTable(url, which=3)
```


## 数据分类

1. 向量 (vector)
2. 矩阵 (matrix)
3. 数据框 (data frame)
4. 列表 (list)
5. 阵列 (array)


### 向量

向量（vector）是R语言中最基本的数据类型，执行组合功能的函数`c()`可用来创建向量

+ 数字向量（numeric vector）

```{r numeric, exercise = TRUE}
vec_num1 <- c(1, 2, 3) #整数
vec_num2 <- c(1:5) #表示1-5 
vec_num3 <- c(1.5, -2.34, NA)
vec_num1; vec_num2; vec_num3
# c(1.5:3) 的结果是什么?
```

注意: 1. `NA`表示的是: not available
      2. 单个向量中的数据必须拥有相同的类型（数值型、字符型或逻辑型）

###

+ 字符向量（character vector）

```{r character, exercise = TRUE}
vec_chr <- c("R is hard.", "But I can nail it.")
vec_chr
```

###

+ 逻辑向量（logic vector）

```{r logic, exercise = TRUE}
vec_tf <- c(TRUE, TRUE, FALSE)
vec_tf
# c(TRUE, TRUE, FALSE) == c(1, 1, 0)
```


###

+ 类别向量（factor vector）

```{r factor, exercise = TRUE}
vec_fac <- factor(c(1, 2, 2, 3), labels = c("Apple", "Pear", "Orange"))
vec_fac
levels(vec_fac)
```

水平(Levels)和标签(Lables)

```{r level, exercise = TRUE}
vec_fac2 <- factor(c(1, 2, 2, 3), levels = c(3, 2, 1), labels = c("Apple", "Pear", "Orange"))
vec_fac2
```


###

+ 时间向量（POSIXct/POSXlt vector）

`as.POSIXct` (numeric input), `as.POSIXlt` (character input)
其中POSIXct是整数存储、POSIXlt是列表存储
```{r time, exercise}
Sys.time() # 获取当前时间
today()   # 获取当日的 年月日
now()  # 获取当日的 年月日 时分秒  时区
# CST为操作时电脑ip所在的时区
# The full pack
time1 <- Sys.time()
time2 <- as.POSIXlt(Sys.time())
time2$wday # week of the day
## 如果我只在乎日期呢？
```

```{r time-solution}
Sys.Date()
date1 <- as.Date("2019-01-02")
class(date1)  # 查看数据类型
```

### 矩阵

矩阵（matrix）是具有维度属性的向量，矩阵都是二维的，和向量类似，矩阵中也仅能包含一种数据类型

```{r out.width = "80%", echo = FALSE}
knitr::include_graphics("images/matrix.gif")
```

###

创建矩阵主要有三种方法：

+ 手动创建: `matrix`
```{r matrixR}
A <- matrix(1:20, ncol = 4) #创建一个数字1-20，5行4列的矩阵（col为列，row为行）
A
A[2, 3]
```

###

+ 矢量+维度: `dim()`
```{r}
M <- c(1:20)
dim(M) <- c(4,5) #4行5列       
M
```

###

+ 绑定行/列: `cbind()`和`rbind()`
```{r}
x <- 1:4
y <- 5:8
cbind (x, y)
rbind (x, y)
```

### 阵列

阵列，顾名思义就是列的“阵”，可用于记录更高维度的数据，可通过`array`函数创建。

```{r array}
# 创建两个长度不同的向量。
vector1 <- c(5,9,3)
vector2 <- c(10,11,12,13,14,15)
# 把这些向量输入到数组中。
result <- array(c(vector1,vector2),dim = c(3,3,2))
result
```

### 列表

列表（list）是一种可包含多种不同类型对象的向量，是一些对象（或成分，component）的有序集合，列表中既可以有向量也可以有矩阵等。

```{r list}
ls_monks <- list(name = c("Wukong Sun", "Sanzang Tang", "Wuneng Zhu", "Wujing Sha"),
                 power = c(100, 20, 90, 40),
                 buddha = c(TRUE, TRUE, FALSE, FALSE))
ls_monks
```

### 数据框

数据框（Data Frame）是一种特殊的列表/矩阵，其中所用元素长度都相等，列表中的每个元素都可以看作一列，每个元素的长度可以看作行数。

在Excel中:

```{r excel, out.width = "80%", echo = FALSE}
knitr::include_graphics("images/excel-r1.png")
```

在R中，使用`data.frame()`创建数据框

```{r dataframe}
df_toy <- data.frame(female = c(0,1,1,0),
           age = c(29, 39, 38, 12),
           name = c("Iron Man", "Black Widow", "Captain Marvel", "Captain America"))
df_toy
```

在Rstudio中:

```{r rstudio}
knitr::include_graphics("images/excel-r2.png")
```


## 合并数据

### 教学数据

我们采用密歇根大学政治学教授Inglehart在[World Values Survey](https://www.worldvaluessurvey.org/wvs.jsp)中使用的数据作为案例来进行下面的讲述。
让我们首先来看看数据

```{r toy, exercise = TRUE}
#wvs7 <- readRDS("/Users/zhumeng/Desktop/Fall semester_2021/Politics analysis/wvs7.rds")
#View(wvs7)
```

### 行合并

```{r out.width = "95%", echo = FALSE}
knitr::include_graphics("images/rowBind.png")
```

假设我们有中国和日本人际信任的数据，如何把它们合并在一起呢？

```{r ex_append, exercise = TRUE}
wvs7_China <- wvs7[wvs7$country == "156", 9:11]
wvs7_Japan <- wvs7[wvs7$country == "392", 9:11]
```

```{r ex_append-solution}
library(dplyr)
wvs7_asia <- bind_rows(wvs7_China, wvs7_Japan) 
#按行连接，不需要列名相同
```

### 列合并

如果我们有一系列的变量，都是来自同一组国家的，如何把他们整合在一起？

```{r out.width = "95%", echo = FALSE}
knitr::include_graphics("images/columnBind.png")
```

```{r ex_columnBind, exercise = TRUE}
wvs7_country <- wvs7$country
wvs7_year <- wvs7$year
```

```{r ex_columnBind-solution}
bind_cols(wvs7_country, wvs7_year) #按列结合时需要行名相同
```

### 索引合并

`dplyr::*_joint`函数

```{r out.width = "95%", echo = FALSE}
knitr::include_graphics("images/join.png")
```

1. 左连接（left_jion): 保留x中的所有观测,如果x中的key变量,在y中有多个同样的key,那么所有的结合可能都会罗列出来。

```{r left_jion, eval=FALSE}
left_join(x, y, by = "key")
```

2. 右连接(right_jion): 保留 y 中的所有观测

```{r right_jion, eval=FALSE}
right_join(x, y, by = "key")
```

### 挑战时间

如果我们有两组数据分别来自不同的源头，又有不同的行数，该如何把它们准确的合并在一起呢？

```{r ex_join, exercise = TRUE}
wvs7_country <- dplyr::select(wvs7,country, year)
wvs7_year <- dplyr::select(wvs7,year,id)
```

```{r ex_join-solution}
wvs7_countryYear<- left_join(wvs7_country, wvs7_year)
```


## 数据输出

语法：<函数>(<代存数据>，file = <存储路径>)

### 储存为R数据

```{r saving, eval = FALSE}
saveRDS(wvs7_country, file = "wvs7_country.rds")
save(wvs7_country, wvs7_year, file = "wvs7_countryYear.rdata")
```


### 储存为csv文件

```{r savingCSV, eval = FALSE}
write.csv(wvs7_country, file = "wvs7_country.csv")
```

提示: 如果你的数据是中文的，可能会出现存储csv乱码现象。
这个我们之后遇到时候再讲解。

当然了，你可以把数据以STATA, SPSS, Excel格式存储下来, 不过你真的想这样吗？

### 体面地储存数据

STATA (.dta, \<14): 3.16 G = R (.rds): 0.05 G

| **Method**       | **Average Time** | **Minimum** | **Maximum** |
|:-----------------|:----------------:|:-----------:|:-----------:|
| base::readRDS    |       19.65      |    18.64    |    21.01    |
| fst::read\_fst   |       1.39       |     0.56    |     3.41    |
| haven::read\_sav |      104.78      |    101.00   |    111.85   |
| qs::qread        |       3.33       |     3.00    |     4.24    |

: 四种在R中读取GSS数据的方式所用的平均时间（以秒计）

| **Method**      | **Average Time** | **Minimum** | **Maximum** | **File Size** |
|:----------------|:----------------:|:-----------:|:-----------:|:-------------:|
| base::saveRDS   |       98.36      |    93.09    |    103.24   |    30.9 MB    |
| fst::write\_fst |       2.70       |     1.86    |     4.05    |    122.1 MB   |
| qs::qsave       |       5.03       |     4.35    |     6.62    |    44.6 MB    |

: 在R中写入GSS数据（及文件大小）所用的平均时间


## 数学计算

```{r math, exercise = TRUE}
x <- y <- 42
# 基础数学
x + (1 - 2) * 3 / 4
# 高等数学
x^2;sqrt(x);log(x);exp(x)
# 矩阵运算
z <- matrix(1:4, ncol = 2)
z + z - z
z %*% z  # inner multiplication
z %o% z  # outter multiplication
# 布尔逻辑计算
x == y; x != y
x & y; x | y
x > y; x <= y
```

在[这里](https://towardsdatascience.com/intro-to-r-linear-algebra-2a4de2506c93)查看更多线性代数在 R 中的应用。

## 总结

1. 输入
    + `readTYPE`
    + `read_type`
    + `read.type`
1. 保存
    + 向量
    + 矩阵/data.frame
    + 列表, 数组
1. 输出
    + `save`
    + `saveTYPE`

### 感谢聆听，下次再见！

<i class="fa fa-envelope fa-lg"></i> <yuehu@tsinghua.edu.cn>

<i class="fa fa-globe fa-lg"></i> <https://sammo3182.github.io/>

<i class="fab fa-github fa-lg"></i> [sammo3182](https://github.com/sammo3182)